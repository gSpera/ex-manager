package ex

import (
	"context"
	"os/exec"
	"strings"
	"sync"

	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"
)

// ExecutionID is an id that rapresent a single execution of an exploit,
// the given ExecutionID is unique across executions(of the program).
type ExecutionID = uuid.UUID

type ExploitState = string

const (
	Paused   ExploitState = "Paused"
	Runnable              = "Runnable"
)

func ExploitStateFromString(state string) (ExploitState, bool) {
	switch state {
	case string(Runnable):
		return Runnable, true
	case string(Paused):
		return Paused, true
	default:
		return Paused, false
	}
}

// VulnerableIndex is used to classify a target vulnerability status.
// It ranges from 0 to 100 where:
//
//   0: The target is completely invulnerable, no attempt will be made, this value can only be setted manualy
//   1: The target has probably patched the Service, a low number of attacks will be attempted
// 100: The target is completely vulnerable, a high number of attacks will be attempted
type VulnerableIndex int

// ServiceExploitName is a tuple of the service and the exploits name,
// it can be used to identify uniquely a exploit
type ServiceExploitName struct {
	ServiceName string
	ExploitName string
}

// Exploit is an attack that can be used against the targets,
// Note that a Exploit doen't rapresent a specific execution,
// instead it contains information for running it
type Exploit struct {
	name string

	service *Service
	state   ExploitState
	ctx     context.Context
	stop    context.CancelFunc

	// set of vulnerable targets
	// if patched contains a value for the Target the exploit will not run against
	patched map[Target]struct{}
	// vulnerableIndex map[Target]int

	// program name
	cmdName      string
	executionDir string

	mutex         sync.Mutex
	targetCounter int
}

// NewExploit creates a new Exploit
func NewExploit(name string, cmdName string, directory string) *Exploit {
	e := &Exploit{}
	e.name = name
	e.ctx, e.stop = context.WithCancel(context.Background())
	e.patched = make(map[Target]struct{})
	e.state = Paused
	e.cmdName = cmdName
	e.executionDir = directory
	e.mutex = sync.Mutex{}
	return e
}

func (e *Exploit) Name() string {
	return e.name
}
func (e *Exploit) CurrentStateString() string {
	return string(e.state)
}
func (e *Exploit) NewState(state ExploitState) {
	e.state = state
}

// Execute executes the attack
// Takes away the gorutine
func (e *Exploit) Execute(lo *log.Entry) {
	id := e.getID()
	target := e.getTarget()
	lo = lo.WithFields(log.Fields{"target": target, "execution-id": id})

	args := make([]string, 0, 4)
	cmdName := strings.Split(e.cmdName, " ")[0]
	args = append(args, strings.Split(e.cmdName, " ")[1:]...)
	args = append(args, target)

	cmd := exec.Command(cmdName, args...)
	cmd.Dir = e.executionDir
	dumper := e.service.session.dumper
	cmd.Stdout = ExploitOutputWriter(lo.WriterLevel(log.InfoLevel), StreamStdout, dumper, target, e, id)
	cmd.Stderr = ExploitOutputWriter(lo.WriterLevel(log.WarnLevel), StreamStderr, dumper, target, e, id)
	lo.Infoln("Running exploit")
	err := cmd.Run()
	if err != nil {
		lo.Errorln("Run:", err)
	}
	lo.Infoln("Done executing exploit")
}

// Stop the exploit, all the runners
func (e *Exploit) Stop() <-chan struct{} {
	return e.ctx.Done()
}

// getTarget iterates aroud all targets and returns a Target
func (e *Exploit) getTarget() Target {
	e.mutex.Lock()
	defer e.mutex.Unlock()
	e.service.session.targetsMutex.Lock()
	defer e.service.session.targetsMutex.Unlock()

	targets := e.service.session.targets
	e.targetCounter++
	e.targetCounter = e.targetCounter % len(targets)
	return targets[e.targetCounter]
}

// exploit id
func (e *Exploit) getID() ExecutionID {
	uid, err := uuid.NewRandom()
	if err != nil {
		return uuid.Nil
	}
	return uid
}

// foundFlag may be called when the worker finds a new flag
func (e *Exploit) foundFlag(target Target, execId ExecutionID, flags ...string) {
	e.mutex.Lock()
	defer e.mutex.Unlock()

	flagInfos := make([]Flag, len(flags))
	for i := range flagInfos {
		flagInfos[i] = Flag{
			ServiceName: e.service.name,
			ExploitName: e.name,
			Value:       flags[i],
			From:        target,
			Status:      FlagNotSubmitted,
			ExecutionID: execId,
		}
	}

	e.service.session.AddFlags(flagInfos...)
}
