package ex

import (
	"context"
	"os/exec"
	"sync"

	log "github.com/sirupsen/logrus"
)

// Exploit is the pool of runners that exploits a Service
type Exploit struct {
	name string

	service *Service
	flags   []string
	ctx     context.Context
	stop    context.CancelFunc

	// set of vulnerable targets
	// if patched contains a value for the Target the exploit will not run against
	patched map[Target]struct{}

	// program name
	cmdName string
	pool    *sync.Pool
}

func NewExploit(name string, cmdName string) *Exploit {
	e := &Exploit{}
	e.name = name
	e.ctx, e.stop = context.WithCancel(context.Background())
	e.patched = make(map[Target]struct{})
	e.cmdName = cmdName
	e.pool = new(sync.Pool)
	return e
}

// Execute executes the attack
func (e *Exploit) Execute() {
	id := e.getID()
	target := e.getTarget()
	lo := newLogger(e.name, e.name, id)
	lo = lo.WithField("target", target)

	cmd := exec.Command(e.cmdName, "-t", target)
	cmd.Stdout = FlagRetriveWriter(lo, e)
	cmd.Stderr = lo.Writer()
	lo.Infoln("Running exploit")
	err := cmd.Run()
	if err != nil {
		lo.Errorln("Run:", err)
	}
	lo.Infoln("Done executing exploit")
}

// FoundFlags may be called when the worker finds a new flag
func (e *Exploit) foundFlag(flags ...string) {
	e.flags = append(e.flags, flags...)
}

// Stop the exploit, all the runners
func (e *Exploit) Stop() <-chan struct{} {
	return e.ctx.Done()
}

// RunTarget starts to the target the exploit, it doen't check if it is vulnerable
// RunTarget returns the exploit id and the error returned in the Start
// RunRarget circumvents the pool
func (e *Exploit) RunTarget(target Target) (int, error) {
	id := getRandomID()
	lo := newLogger(e.name, e.name, id)

	cmd := exec.Command(e.cmdName, "-t", target)
	cmd.Stdout = lo.Writer()
	cmd.Stderr = lo.Writer()
	err := cmd.Start()
	return id, err
}

func (e *Exploit) getTarget() string {
	return e.service.session.randomTarget()
}

func (e *Exploit) getID() int {
	return 0
}
func (e *Exploit) log() *log.Entry {
	return e.service.session.log
}
