package ex

import (
	"context"
	"os/exec"
	"strings"
	"sync"

	log "github.com/sirupsen/logrus"
)

type ExploitState = string

const (
	Paused  ExploitState = "Paused"
	Running              = "Running"
)

func ExploitStateFromString(state string) (ExploitState, bool) {
	switch state {
	case string(Running):
		return Running, true
	case string(Paused):
		return Paused, true
	default:
		return Paused, false
	}
}

// ServiceExploitName is a tuple of the service and the exploits name,
// it can be used to identify uniquely a exploit
type ServiceExploitName struct {
	ServiceName string
	ExploitName string
}

// Exploit is an attack that can be used against the targets,
// Note that a Exploit doen't rapresent a specific execution,
// instead it contains information for running it
type Exploit struct {
	name string

	service *Service
	state   ExploitState
	ctx     context.Context
	stop    context.CancelFunc

	// set of vulnerable targets
	// if patched contains a value for the Target the exploit will not run against
	patched map[Target]struct{}

	// program name
	cmdName      string
	executionDir string

	mutex     sync.Mutex
	idCounter int
}

// NewExploit creates a new Exploit
func NewExploit(name string, cmdName string, directory string) *Exploit {
	e := &Exploit{}
	e.name = name
	e.ctx, e.stop = context.WithCancel(context.Background())
	e.patched = make(map[Target]struct{})
	e.state = Paused
	e.cmdName = cmdName
	e.executionDir = directory
	e.mutex = sync.Mutex{}
	e.idCounter = 0
	return e
}

func (e *Exploit) Name() string {
	return e.name
}
func (e *Exploit) CurrentStateString() string {
	return string(e.state)
}
func (e *Exploit) NewState(state ExploitState) {
	e.state = state
}

// Execute executes the attack
// Takes away the gorutine
func (e *Exploit) Execute() {
	id := e.getID()
	target := e.getTarget()
	lo := newLogger(e.service.Name(), e.name, id)
	lo = lo.WithField("target", target)

	args := make([]string, 0, 4)
	cmdName := strings.Split(e.cmdName, " ")[0]
	args = append(args, strings.Split(e.cmdName, " ")[1:]...)
	args = append(args, "-t", target)

	cmd := exec.Command(cmdName, args...)
	cmd.Dir = e.executionDir
	cmd.Stdout = FlagRetriveWriter(lo, target, e)
	cmd.Stderr = lo.Writer()
	lo.Infoln("Running exploit")
	err := cmd.Run()
	if err != nil {
		lo.Errorln("Run:", err)
	}
	lo.Infoln("Done executing exploit")
}

// Stop the exploit, all the runners
func (e *Exploit) Stop() <-chan struct{} {
	return e.ctx.Done()
}

// random target
func (e *Exploit) getTarget() string {
	return e.service.session.randomTarget()
}

// exploit id
func (e *Exploit) getID() int {
	e.mutex.Lock()
	defer e.mutex.Unlock()
	counter := e.idCounter
	e.idCounter++
	return counter
}

func (e *Exploit) log() *log.Entry {
	return e.service.session.log
}

// foundFlag may be called when the worker finds a new flag
func (e *Exploit) foundFlag(target Target, flags ...string) {
	e.mutex.Lock()
	defer e.mutex.Unlock()
	flagInfos := make([]Flag, len(flags))
	for i := range flagInfos {
		flagInfos[i] = Flag{
			ServiceName: e.service.name,
			ExploitName: e.name,
			Value:       flags[i],
			From:        target,
			Status:      FlagNotSubmitted,
		}
	}

	e.service.session.AddFlags(flagInfos...)
}
