package ex

import (
	"context"
	"os/exec"
	"sync"

	log "github.com/sirupsen/logrus"
)

type ExploitState = string

const (
	Paused  ExploitState = "Paused"
	Running              = "Running"
)

// Exploit is the pool of runners that exploits a Service
type Exploit struct {
	name string

	service *Service
	state   ExploitState
	flags   map[Target][]Flag
	ctx     context.Context
	stop    context.CancelFunc

	// set of vulnerable targets
	// if patched contains a value for the Target the exploit will not run against
	patched map[Target]struct{}

	// program name
	cmdName string
	pool    *sync.Pool
}

func NewExploit(name string, cmdName string) *Exploit {
	e := &Exploit{}
	e.name = name
	e.ctx, e.stop = context.WithCancel(context.Background())
	e.patched = make(map[Target]struct{})
	e.state = Paused
	e.cmdName = cmdName
	e.flags = make(map[Target][]Flag)
	e.pool = new(sync.Pool)
	return e
}

func (e *Exploit) Name() string {
	return e.name
}
func (e *Exploit) CurrentStateString() string {
	return string(e.state)
}
func (e *Exploit) NewState(state ExploitState) {
	e.state = state
}

func (e *Exploit) Flags() map[Target][]Flag {
	return e.flags
}

// Execute executes the attack
// Takes away the gorutine
func (e *Exploit) Execute() {
	id := e.getID()
	target := e.getTarget()
	lo := newLogger(e.name, e.name, id)
	lo = lo.WithField("target", target)

	cmd := exec.Command(e.cmdName, "-t", target)
	cmd.Stdout = FlagRetriveWriter(lo, target, e)
	cmd.Stderr = lo.Writer()
	lo.Infoln("Running exploit")
	err := cmd.Run()
	if err != nil {
		lo.Errorln("Run:", err)
	}
	lo.Infoln("Done executing exploit")
}

// Stop the exploit, all the runners
func (e *Exploit) Stop() <-chan struct{} {
	return e.ctx.Done()
}

// random target
func (e *Exploit) getTarget() string {
	return e.service.session.randomTarget()
}

// exploit id
func (e *Exploit) getID() int {
	return 0
}

func (e *Exploit) log() *log.Entry {
	return e.service.session.log
}

// foundFlag may be called when the worker finds a new flag
func (e *Exploit) foundFlag(target Target, flags ...string) {
	if e.flags[target] == nil {
		e.flags[target] = []Flag{}
	}
	e.flags[target] = append(e.flags[target], flags...)
}
